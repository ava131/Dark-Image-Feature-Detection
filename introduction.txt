任务前说明
对于以下任务，请使用 Pic1 作为超暗图像（记为 Dark-1）。其对应的长曝光正常亮度图像是 GT1（记为 Bright-1）。

所有原始图像均为 RGB 格式（彩色图像），但您也可以为了方便转换为灰度图像。如果您打算为任务转换为灰度图像，请首先展示灰度转换的步骤和结果。

重要！ 您可以使用 OpenCV 或其等效库的任何函数进行基本操作（例如，加载图像、矩阵计算等），但严格禁止使用直接针对每个独立任务/步骤的函数（例如，用于 Canny 边缘检测的 cv2.Canny 或其等效函数，以及用于直方图均衡化的 cv2.equalizeHist）。使用此类函数将被视为代码错误。

任务 1：超暗图像中的 Canny 边缘检测和 Harris 角点检测 (60%)
在此任务中，您需要实现 Canny 边缘检测算法，并尝试通过图像增强方法提高其性能。您需要讨论超暗图像的特性如何影响 Canny 边缘检测的性能，以及不同的图像增强方法会如何改善/影响超暗图像上 Canny 边缘检测的性能。您需要遵循以下步骤（要求）：

任务 1 的详细步骤/要求：
计算 Dark-1 和 Bright-1 的图像直方图，然后讨论您的观察结果。超暗图像的特性是什么，以及如何通过图像直方图观察到这些特性。(10%)

对 Dark-1 和 Bright-1 执行 Canny 边缘检测。对于至少一张图像，展示 Canny 边缘检测每个关键步骤（例如，图像平滑后、计算偏导数后、应用阈值后等）的输出以及最终输出。观察并比较 Canny 边缘检测在 Dark-1 和 Bright-1 上的性能，并讨论您观察到该结果的原因。(10%)

对 Dark-1 和 Bright-1 执行 Harris 角点检测器检测。对于至少一张图像，展示 Harris 角点检测器检测每个关键步骤的输出以及最终输出。观察并比较 Harris 角点检测器检测在 Dark-1 和 Bright-1 上的性能，并讨论您观察到该结果的原因。(10%)

从零开始实现直方图均衡化（HE） 并应用于 Dark-1。输出 HE 的结果（记为 Dark-1-HE）并讨论您的观察：HE 如何改变/改进采样图像。假设 Canny 边缘检测和 Harris 角点检测在 Dark-1-HE 上的输出会是什么样子。(10%)

将您实现的 Canny 边缘检测和 Harris 角点检测应用于您经过 HE 增强的采样图像，并展示最终输出。最终输出是否符合您的假设？如果符合，请论证您的假设。如果不符合，请描述并解释差异。同时讨论这些结果与 Bright-1 的结果相比如何？(10%)

最后，选择一种您偏好的图像增强方法。说明选择了哪种图像增强方法。使用适当的注释实现它，并输出结果（记为 Dark-1-Self）。将 Canny 边缘检测和 Harris 角点检测应用于 Dark-1-Self 并显示结果。讨论 Dark-1-Self 与 Dark-1-HE 之间的差异。进一步观察、比较并论证 Dark-1、Dark-1-HE、Dark-1-Self 和 Bright-1 之间检测到的边缘和角点的差异。(10%)

关于步骤 6 的说明：对于所选的图像增强方法，您可以使用开源代码或 OpenCV 中的直接函数或其等效函数。

要点总结
核心任务：在超暗图像（Dark-1）上实现 Canny 边缘检测和 Harris 角点检测，并研究图像增强方法（特别是直方图均衡化 HE 和另一种自选方法）对其性能的影响。

关键要求：

禁止使用现成的高级函数：必须从零实现 Canny、Harris 和直方图均衡化（HE），不能直接调用 cv2.Canny, cv2.cornerHarris, cv2.equalizeHist 等函数。

展示过程：对于至少一张图像，需要展示 Canny 和 Harris 算法关键中间步骤的输出图像。

分析与讨论：每个步骤都要求有相应的观察、比较、假设和原理性讨论，解释"为什么"会出现某种结果。

图像格式：可以使用彩色或灰度图。如果转为灰度图，需先展示转换步骤和结果。

具体步骤分解：

步骤 1：分析原图（Dark-1, Bright-1）的直方图，理解超暗图像的特性。

步骤 2 & 3：在原始图像上应用自实现的 Canny 和 Harris，对比其在暗图和亮图上的性能差异并分析原因。

步骤 4：自实现直方图均衡化（HE）处理 Dark-1，得到 Dark-1-HE，并预测增强后图像的边缘/角点检测效果。

步骤 5：在 Dark-1-HE 上运行自实现的 Canny 和 Harris，验证预测，并与 Bright-1 的结果比较。

步骤 6：选择并实现另一种图像增强方法处理 Dark-1，得到 Dark-1-Self。比较 Dark-1-Self、Dark-1-HE、Dark-1 和 Bright-1 的边缘/角点检测结果，分析不同增强方法带来的差异。（此步骤允许使用现成的增强函数）

输出成果：需要提交代码、一系列中间步骤和最终结果的图像、以及详细的讨论分析。


任务前说明
对于以下任务，请使用 GT1（记为 Bright-1）和 GT2（记为 Bright-2）作为立体图像对。

所有原始图像均为 RGB 格式（彩色图像），但您也可以为了方便转换为灰度图像。如果您打算转换为灰度图像，请首先展示灰度转换的步骤和结果。

如果您认为图像太大，可以选择调整图像大小，但调整后的图像不得小于 800*800 像素。如果您选择调整图像大小，请首先展示调整大小的步骤和结果。

重要！ 您可以使用 OpenCV 或其等效库的任何函数进行基本操作（例如，加载图像、矩阵计算等），但严格禁止使用直接针对每个独立任务/步骤的函数（例如，用于计算和绘制极线的 cv.computeCorrespondEpilines 和用于计算基础矩阵的 cv.findFundamentalMat）。使用此类函数将被视为代码错误。

任务 2：计算立体图像对的基础矩阵和寻找极线 (40%)
在此任务中，您需要基于（归一化）8点算法计算基础矩阵。您需要手动选择关键点（可以使用如 Windows 的画图等工具），然后计算基础矩阵。接着，您需要为您选择的关键点寻找、绘制、观察并讨论极线。您需要遵循以下步骤（要求）：

任务 2 的步骤/要求：
手动查找并高亮显示图像中的关键点。对于 8 点算法，您应选择至少 8 个非共线点。以齐次坐标说明各个位置，并在相应的图像中高亮显示它们。如果您选择使用归一化 8 点算法，您应说明原始关键点和归一化后关键点的坐标，并展示您的归一化代码，但您只需高亮显示原始关键点。如果您发现在像素级别高亮显示很困难，可以使用以所选关键点为中心的小圆进行高亮显示。(10%)

使用选定的关键点，详细计算基础矩阵 F。说明得到的基础矩阵。(10%)

利用基础矩阵，在两幅图像上绘制与所选关键点对应的所有极线。观察并讨论这些线如何指示相机的位置。同时讨论计算出的线是否符合您对线应如何形成的直观想法。如果符合，为什么？如果不符合，又为什么？(10%)

最后，利用计算出的基础矩阵，给定 Bright-1 上一个新的关键点（该点不位于任何已绘制的极线上），我们也能够找到其对应的极线，进而在 Bright-2 上找到对应的关键点。在 Bright-1 上选择一个新的关键点，然后在 Bright-2 上绘制与该新关键点对应的极线。观察并讨论是否可以通过沿绘制的极线搜索来找到一个可能的关键点。(10%)

要点总结
核心任务：手动选择特征点，实现（归一化）8点算法来计算基础矩阵 F，并利用 F 绘制和分析极线。

关键要求：

禁止使用现成的高级函数：必须自己实现 8 点算法和极线计算，不能直接调用 cv.findFundamentalMat, cv.computeCorrespondEpilines 等函数。

手动选择点：需要至少选择 8 对非共线的对应点。需提供点的（齐次）坐标并在图像上高亮标出。

分析与讨论：需要讨论极线如何反映相机几何关系，并验证新点的极线约束。

图像格式：可以使用彩色或灰度图。如果转为灰度图或调整大小，需先展示转换步骤和结果。调整后图像尺寸需 >= 800x800。

具体步骤分解：

步骤 1：在两幅图像上手动选择至少 8 对对应点，记录其齐次坐标并在图上标出。如果使用归一化8点算法，需展示归一化过程。

步骤 2：根据选择的点对，实现（归一化）8点算法，计算基础矩阵 F，并给出最终的 F 矩阵。

步骤 3：利用计算出的 F 矩阵，为步骤 1 中选择的每个点在另一幅图像上计算并绘制对应的极线。分析极线形态与相机位置的关系，并与直觉进行比较讨论。

步骤 4：在 Bright-1 上新选一个点（不在步骤1的点集中），计算其在 Bright-2 上的极线并绘制。讨论沿此极线搜索对应点的可行性。

输出成果：需要提交代码、标有关键点的图像、计算出的 F 矩阵、绘有极线的图像、以及详细的讨论分析。